// Generated by LiveScript 1.4.0
var Promise, amqp, Queue, uuid, Connection, out$ = typeof exports != 'undefined' && exports || this;
Promise = require('bluebird');
amqp = require('amqp');
Queue = require('./queue').Queue;
uuid = require('./utils').uuid;
out$.Connection = Connection = (function(){
  Connection.displayName = 'Connection';
  var prototype = Connection.prototype, constructor = Connection;
  function Connection(host, exchangeName, options, exchangeOptions){
    this.host = host;
    this.exchangeName = exchangeName;
    this.options = options != null
      ? options
      : {};
    this.exchangeOptions = exchangeOptions != null
      ? exchangeOptions
      : {};
    if (!this.host) {
      throw new Error('host must be declared');
    }
    if (!this.exchangeName) {
      throw new Error('exchange-name must be declared');
    }
    this.connection = amqp.createConnection({
      host: this.host
    });
  }
  prototype.connect = function(){
    var this$ = this;
    return new Promise(function(resolve, reject){
      this$.connection.on('ready', function(){
        this$.exchange = this$.connection.exchange(this$.exchangeName, this$.exchangeOptions);
        return this$.exchange.on('open', function(){
          return resolve(this$);
        });
      });
      return this$.connection.on('error', function(error){
        return reject(error);
      });
    });
  };
  prototype.withQueue = function(queueName, routingKeys, queueOptions){
    var this$ = this;
    routingKeys == null && (routingKeys = ['#']);
    queueOptions == null && (queueOptions = {});
    return new Promise(function(resolve, reject){
      return this$.connection.queue(queueName, queueOptions, function(queue){
        var e;
        try {
          return resolve(new Queue(queue, this$, routingKeys, queueOptions));
        } catch (e$) {
          e = e$;
          return reject(e);
        }
      });
    });
  };
  prototype.dial = function(routingKey, message, publishOptions, willReply){
    var this$ = this;
    publishOptions == null && (publishOptions = {});
    willReply == null && (willReply = false);
    return new Promise(function(resolve, reject){
      var ref$, id, tempName, tempRoute, tempQueue;
      publishOptions.headers == null && (publishOptions.headers = {});
      (ref$ = publishOptions.headers)['x-timestamp'] == null && (ref$['x-timestamp'] = new Date().getTime());
      if (willReply) {
        id = uuid();
        tempName = function(x){
          return "temp-" + x + "-" + id;
        };
        tempRoute = tempName('route');
        tempQueue = tempName('queue');
        publishOptions.replyTo == null && (publishOptions.replyTo = tempRoute);
        return resolve(this$.withQueue(tempQueue, [tempRoute], {}).then(function(queue){
          this$.exchange.publish(routingKey, message, publishOptions);
          return queue.first();
        }));
      } else {
        return this$.exchange.publish(routingKey, message, publishOptions, function(result){
          return resolve(result);
        });
      }
    });
  };
  prototype.ask = function(routingKey, message, publishOptions, willReply){
    publishOptions == null && (publishOptions = {});
    willReply == null && (willReply = true);
    return this.dial(routingKey, message, publishOptions, willReply);
  };
  prototype.hang = function(){
    var this$ = this;
    return new Promise(function(resolve, reject){
      return resolve(this$.connection.disconnect());
    });
  };
  return Connection;
}());